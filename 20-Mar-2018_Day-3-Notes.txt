srinivasa.challa@marlabs.com
9703645810
======
Day-3:
======
1) Types Of Relations In Java

2) Object Class Methods

3) Abstract Classes And Interfaces

4) Dynamic Binding Concepts

5) Some Programs On This..

Types Of Relations In Java:
===========================
>> Code Re-Usability Technique

Note:
=====
class Demo{
			protected int i;

}
class Demo1 extends Demo{

}
class Demo2 extends Demo1{
		i=20;		// I Am Getting Compile Time Error
		void display(){
			Syso(i);
		}		
}
public class MainApp{
	psvm(String args){
		
	}
}

Answer:
Every Operation In Java We Are Supposed to Perform With Respect To A Method

1) IS A Relation 		==> Generalization  ===> Inheritance
	
2) Has A Relation		==> Aggregation	

	public Class Address{
					String cityName;
					String stateName;
					long pinCode;
					String houseNumber;
					String streetName;
					// Setters or Cons
					// Getters As Well
	
	}
	public class Employee{
					int empNumber;
					String empName;	  //  Aggregation or HAS A Relation	
					Address pAddress; //  Aggregation or HAS A Relation
					Address lAddress; //  Aggregation or HAS A Relation
					// Methods
	}

>> One - to - One
>> One - to - Many
	
3) Uses A Relation		===> Association

	public void readEmpDetails(){
		// USES A RELATIOn
		Scanner sc=new Scanner(System.in); // JDK 1.5 Version
		Syso("Enter Emp Number");
		int empNumber=sc.nextInt();
		sc.close();
	}
	
===============	
Factory Method:
===============
		1) Calendar.getInstance();
		
		2) 
		public synchronized static MySingleTon getInstance() {
		if (mySingleTonInstance == null) {
			mySingleTonInstance = new MySingleTon();
			mySingleTonInstance.loadUserDetails();
		}
		return mySingleTonInstance;
		}

		3) DateFormat.getDateInstance(arg0, arg1);
		
  >> If We want to create an Object
	 Without using a new keyword we are going for factory methods.
	 
  >> by default factory methods are public and static
  
  >> Factory Method try's to return an Object of Same class
	  in which it is belongs to.

=====================
Object Class Methods:
=====================
java.lang.Object ===> Class

1) Class getClass();

2) int hashCode();	

	>> HashCode is unique identification number,
		generated by the JVM for its Internal Processing
		And it is not a Memory Location Number.
		
	>> Yes It IS Possible to Override hashCode Method
	
	>> Is it possible to get negative Numbers For HashCode?
		Yes

3) boolean equals();
	 What is the need to override both equals and Hash Code Methods?
	 Is it Mandatory To Override both Methods?		
	 
 Contract Between equals And hashCode Methods:
 
	>> If two objects were said to be equals,
	then must and shouldly both objects hashcodes should be same.
	
	>> However if we are not overrides both the methods you wont get any difference
		but while working with collections it is mandatory.
	 

4) String toString();

5) Object clone()throws CloneNotSupportedException
	Default - Shallow Cloning
		
	>> Deep Cloning?
		>> In What Scenariao's We are going for Deep Cloning?
		>> Need An Explanation With Sample Code
		
	
6) void finalize();

7) notifY(), notifyAll();
   wait(), wait(--) ..
	Related To Thread's
	

Abstract Class And Interfaces:
=============================
	Why we need an abstract Method?
		>> To force the sub class developer to 
			- adhere the protocols which we specify in the base class.
		>> To Define Protocols
		etc..

Interfaces:
===========
>> In Interfaces We have only public abstract methods

>> Used to define the protocols

>> public static final variables only

>> All general Purpose Methods

>> Via Interfaces Multiple Inheritance is Possible.

>> Interface to Interface 	- extends

>> Interface to Class	  	- implements

>> Yes, Interface Inheritance is Possible	


public class InterfaceImpl extends C1 implements Inter2,Inter3{

	// Methods Implementation
}
Note:
>> Whenever we are using the combination of extends and implements keywords
 the first keyword is extends, and it followed by implements

>> Example:
===========

public interface IEmployee{

	public abstract  setEmpPassWord(String empPassWord);
	
	public abstract String getEmpPassWord();

	public abstract void doSalaryCaliculation();
	
	public abstract void displaySalaryStatement();

	double HRA_PERCENTILE=0.04; // public final static double HRA_PERCENTILE=0.04;
	
	public final static double DA_PERCENTILE=0.03d;
}

==>class PEmployee implements IEmployee{
			// setEmpPassWord
			// getEmpPassWord
			// doSalaryCaliculation
			// displaySalaryStatement
	}
==> class CEmployee implements IEmployee{
			// setEmpPassWord
			// getEmpPassWord
			// doSalaryCaliculation
			// displaySalaryStatement
	}
==> class HEmployee implements IEmployee{
			// setEmpPassWord
			// getEmpPassWord
			// doSalaryCaliculation
			// displaySalaryStatement
	}

Solution:
=========
Employee.java
	public abstract Employee implements IEmployee{
			// setEmpPassWord
			// getEmpPassWord
			// displaySalaryStatement		
	}
	
PEmployee.java
	public class PEmployee extends Employee{
		public double doSalaryCaliculation(){
			// BL
		}
	}
CEmployee.java

	public class CEmployee extends Employee{
		public double doSalaryCaliculation(){
			// BL
		}
	}
===================
Practical Scenario:
===================
			Servlet Interface
				||	5 Life Cycle Methods
				||
			GenericServlet Abstract Class
				||
				||
			HttpServlet Abstract Class
				||
				||
		public class EmployeeRegistrationServlet extends HttpServlet{
			// doGet or doPost, service();
		}

Next Session:
============
>> Exception Handling
>> IO Package
		- Serialization
		- De-Serialization
>> Few Interview Questions On This Concepts

>> String and StringBuffer API

After:
>> java.util.*;
		Date
		Calendar
		Random
		StringTokenizer
>> java.text.*;
		DateFormat
		SimpleDateFormat
>> Coding Examples

After:
Collections FrameWork
JDK 1.8 Features
JUNIT
JDBC

















