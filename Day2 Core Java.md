# Day2 Core Java
## content including:

### Facotry Design Patterns and Factory Method
    Factory method, usually public and static: instant of using new operator to create object, factory method returns an object of same class in which it belongs to.
    e.g. Calendar.getInstance()
         DateFormat.getDateInstance()

    There are there versions of Factory Pattern:
    1.1 Simiple Factory Pattern
        twp types of class are invloved in this design pattern: factory and product.product class has inheritance 
        factory a simple class that are responsible for creating concreate products objects by the giving parameters.
        products are more complicate, that's why we need factory class to create their objects for them. normally, there is a base product class or interface, than inheirtanced by muliple subclasses. these subclass have different parameters and are different with each other. factory class know these differences, so just by giving the parameters, the factory class can create the correct subclass for the user.

    [Ref: simple factory] {https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html}
    1.2 Factory Method Pattern
        four types of classes are envoloved in this pattern. Factory interface and Factory concrete classes, Product interface and Product concrete classes. 
        e.g. log factory example (https://design-patterns.readthedocs.io/zh_CN/latest/_images/loger.jpg "factory methods example")
        in this example, each and every concrete log has a concreate factory to create objects. however, client don't know the details of these concrete classes. the client only knows log and logFactory. By using LogFactory's overriding methods, in the run time, clients get the log objects that they want. 

    1.3 Abstract Factory Pattern
        factory can create different products. more abstract classes envoloved. each concreate factory might responsible for creating more than one concreate product objects. 
        here is the example:
        {https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg}
### Object Class Methods:
    java.lang.Object is the super class for every class in java, it contains some important 
    2.1  Class getClass()  equally? method Class.forName()
        Object.getClass() returns the class of the object
        Class.forName() take the String vlaue of class name as a parameter and returns the class.
    2.2 int hashCode()
        HashCode is unique identification number,
        generated by the JVM for its Internal Processing
        And it is not a Memory Location Number.
        returns the hash value of a object. 
        hashCode() is important because in the hashtMap/hashSet... use this value as the identification of a object.
    2.3 boolean equals()
        returns true only when both the references are pointing to same object.
    2.4  If two objects are equal according to equals() method, then their hash code must be same.If two objects are unequal according to equals() method, their hash code are not required to be different. Their hash code value may or may-not be equal.

    2.5 When to override equals() and hashCode() methods?
       When we override equals() method, itâ€™s almost necessary to override the hashCode() method too so that their contract is not violated by our implementation. [example:] {https://www.journaldev.com/21095/java-equals-hashcode}
       `public class DataKey {

            private String name;
            private int id;
                // getter and setter methods
            @Override
            public String toString() {
                return "DataKey [name=" + name + ", id=" + id + "]";
            }
        }
        public class HashingTest {
            public static void main(String[] args) {
                Map<DataKey, Integer> hm = getAllData();

                DataKey dk = new DataKey();
                dk.setId(1);
                dk.setName("Pankaj");
                System.out.println(dk.hashCode());

                Integer value = hm.get(dk);

                System.out.println(value); // here should print null

            }

            private static Map<DataKey, Integer> getAllData() {
                Map<DataKey, Integer> hm = new HashMap<>();

                DataKey dk = new DataKey();
                dk.setId(1);
                dk.setName("Pankaj");
                System.out.println(dk.hashCode());

                hm.put(dk, 10);

                return hm;
            }
        }`

        the reason of null is they are different object, which has different hashcode value. even the two object contains the same data. 

    2.6 interview questions:
        
            + Yes It IS Possible to Override hashCode Method
    
            + Is it possible to get negative Numbers For HashCode?
                Yes    

    2.7  String toString()   
    2.8 Object clone()throws CloneNotSupportedException
    `   /*
        Creates and returns a copy of this object. The precise meaning of "copy" may depend on the class of the object.
        The general intent is that, for any object x, the expression:
        1) x.clone() != x will be true
        2) x.clone().getClass() == x.getClass() will be true, but these are not absolute requirements.
        3) x.clone().equals(x) will be true, this is not an absolute requirement.
        */
        protected native Object clone() throws CloneNotSupportedException;`
        the explaining of this comment as:
        First statement guarantees that cloned object will have separate memory address assignment.
        Second statement suggest that original and cloned objects should have same class type, but it is not mandatory.
        Third statement suggest that original and cloned objects should have be equal using equals() method, but it is not mandatory.

        JVM when called for cloning, do following things:
        If the class has only primitive data type members then a completely new copy of the object will be created and the reference to the new object copy will be returned.
        If the class contains members of any class type then only the object references to those members are copied and hence the member references in both the original object as well as the cloned object refer to the same object.
        [ a very good reference article addressing this problem]{https://howtodoinjava.com/java/cloning/a-guide-to-object-cloning-in-java/}
        
        this clone method makes shallow copy by default. 
        what is shallow copy and deep copy? how to make a deep copy?
        when copy a object, shallow copy only copies its refrence, the memory address of this object. when we do something on the copied object, the original object changes accordingly. 
        In the deep copy, we create a clone which is independent of original object and making changes in the cloned object should not affect original object.

        So deep cloning requires satisfaction of following rules. 
        - No need to separately copy primitives.
        - All the member classes in original class should support cloning and in clone method of original class in context should call super.clone() on all member classes.
        - If any member class does not support cloning then in clone method, one must create a new instance of that member class and copy all its attributes one by one to new member class object. This new member class object will be set in cloned object.

    2.9  clonable and serializable are maker or tagged interfaces, which means the interface has no method. 
    - interview qustion: 
      how to use maker interface?
      is it possible to make your own maker interface?



    2.10 Object.clone() and Object.finalize() are protected method, by overriding them, it's posible to increse their visiablity, e.g to public but can not reduce the visiablity. e.g. to private or default.

###  interface and abstract method
    3.1 why need them?
        - To force the sub class developer to 
            - adhere the protocols which we specify in the base class.
        - To Define Protocols
    3.2 about interface:
        - Interfaces We have only public abstract methods
        - public static final variables only
        - All general Purpose Methods
        - Via Interfaces Multiple Inheritance is Possible
        - Interface to Interface    -> extends
        - Interface to Class        -> implements
        - Yes, Interface Inheritance is Possible
        - Whenever we are using the combination of extends and implements keyword the first keyword is extends, and it followed by implements
    3.3 why need to combine abstrct class and interface?
        eg. having an IEmployee interface contains certain methods and final static data. why need abstract employee implements IEmployee? because we don't want to implement all interface method. 
### IO Package
        4.1 Serialization
            The process of saving the state of an object permanently in 
            the secondary memory
        4.2 De-Serialization
            The process of reading the object from secondary memory to primary memory
        4.3 Best Way of Doing Singleton Class
            How to Serialize and De-Serialize Singleton Objects.
            By serializing and de-serializing Singleton objects, we can fin d that singleton can be broken. the way to prevent, is implement readResolve() method.
            in the Singleton class
            '// implement readResolve method 
                protected Object readResolve() 
                { 
                    return instance; 
                }'
            we also need to eliminate the clone possibility by override clone() method. and make it throe CloneNotSupportedException
            `@Override
                  protected Object clone() throws CloneNotSupportedException  
                  { 
                    throw new CloneNotSupportedException(); 
                  } 
                } `
        4.3 Stream
            a flow of data between source and destination
            source e.g. keyborad, file
            destination: file, console etc. 
            - input stream          ==> reading operation
            - output strean         ==> writing operation
           another two type:
           - byte oriented streams  ===> 1 Byte at a time 
                ends with inputStream\outputStream
           - charchter oriented streams => 2 Byte at a time
                ends with Reader\Writer
           - IOException, FileNotFoundException are checked exception, which means you have to fix forced by compiler.
         4.4 serializable, cloneable interface are marker or tagged interfaces, meaning that these interface has no method
         4.5 serializtion then de-serialization will not be same reference
                not in the same memory location
         e.g. code 
         `package com.marlabs.training.Day4;
            import java.io.Serializable;
            public class Customer implements Serializable {
                private String customerId;
                private String customerName;
                private String customerPwd;
                private long customerPinCode;
                private String customerCity;

                // getter setter constructor and toString
            }`
            'public class MainApplication {
                public static void serializeObject(final Customer customer) {
                    FileOutputStream fOutputStream = null;
                    ObjectOutputStream ObjectOutputStream = null;
                    try {
                        fOutputStream = new FileOutputStream("src/data.txt");
                        ObjectOutputStream = new ObjectOutputStream(fOutputStream);
                        ObjectOutputStream.writeObject(customer);
                    } catch (FileNotFoundException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    } catch (IOException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    } finally {
                        try {
                            if (fOutputStream != null) {
                                fOutputStream.close();
                            }
                            if (ObjectOutputStream != null) {
                                ObjectOutputStream.close();
                            }
                        } catch (IOException e2) {
                            // TODO: handle exception
                        }
                    }

                }

                public static void deSerializeObject() {
                    FileInputStream fInputStream = null;
                    ObjectInputStream oInputStream = null;
                    try {
                        fInputStream = new FileInputStream("src/data.txt");
                        oInputStream = new ObjectInputStream(fInputStream);
                        Customer customer = (Customer) oInputStream.readObject();
                        System.out.println("DESERIALIZE OBJECT DONE");
                        System.out.println(customer);
                    } catch (IOException e) {
                        // TODO: handle exception
                    } catch (ClassNotFoundException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    } finally {
                        try {
                            if (fInputStream != null) {
                                fInputStream.close();
                            }
                            if (oInputStream != null) {
                                oInputStream.close();
                            }
                        } catch (IOException e2) {
                            // TODO: handle exception
                        }
                    }

                }

                public static void main(String[] args) {
                    System.out.println("start main method");
                    System.out.println("######################");
                    System.out.println("1) Serialize the object");
                    System.out.println("2) De-Serialize the object");
                    System.out.println("3) Exit");
                    Scanner scanner = new Scanner(System.in);
                    System.out.println("please input your choice");
                    int choice = scanner.nextInt();
                    switch (choice) {
                    case 1:
                        Customer customer = new Customer("84990", "hhh", "123", 0000, "somecity");
                        serializeObject(customer);
                        System.out.println("object serialized sucessfully");
                        break;
                    case 2:
                        deSerializeObject();
                        break;
                    default:
                        System.exit(0);
                        break;
                    }
                    System.out.println("######################");
                    System.out.println("end main method");
                }
            }'
